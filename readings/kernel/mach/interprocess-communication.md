## 0x04 IPC(进程间通信）

### 4.1 主要概念

原文链接[请点击这里](https://www.gnu.org/software/hurd/gnumach-doc/Major-Concepts.html#Major-Concepts)。

Mach内核提供了面向消息的，稳定的`进程间通信`。IPC原语高效地支持许多不同的交互方法，比如RPC（远程调用），面向对象的分布式编程，数据流，甚至更大的数据块。

`IPC原函数`操作三种抽象数据类型：

- messages
- ports
- port sets

用户态的任务通过`IPC原函数`访问其它（抽象的）服务。

`message原函数`完成所有**任务**发送和接收消息的工作，并保证`message`传输稳定到达和接收顺序。`message`包含一个固定长度的`header`和变长的`data`，`header`描述了包的目的地和消息大小；

`IPC`的实现复用`VM系统`高效地实现大师数据的传输。消息体内包含数据块的发送者`用户态`内存地址，接收消息的**Task**使用自己的内存地址引用消息中的数据块。这种优化后的传输方式使得发送者和接收者可共享数据的物理地址（`内核态`），当对数据发生`写`操作时再`Copy`一份，即Copy-On-Write。

`Ports`其实就是一个`消息队列（queue of messages）`，**Tasks**通过操作`Port`来实现`发送`和`接收`消息；一个，或多个**Task**可以共同拥有一个`发送`能力（或权力）的Port，也可以拥有一个**仅发送一次**的Port。然而，对`Port`拥有`接收`能力（或权力）的**Task**只能有一个。发送**Task**可以在消息体内指定`Port`的能力（或权力），假如一个消息体包含一个`接收`能力（或权力），则消息发出后，`发送`的**Task**将被取消`接收`的能力（或权力），消息`接收`的**Task**则会能消息`接收`能力（或权力）。

**Tasks**可从`Ports`和`Port Set`接收消息。`Port Set`抽象了一个线程可以接收任意多个`Ports`消息的使用场景。**Task**使用相同的`Port`能力（或权力）操作`Port Set`，并且`Port Set`的能力（或权力）不能在消息中进行传输。若`Port Set`拥有`接收`能力（或权力），一个`接收`操作将阻塞`Port Set`的`发送`操作，并且一个`Port`不能属于多个`Port Set`。

`Port`权限是一个安全的，与位置无关的命名方式。`Port Queue`是一个受保护的数据结构，只能通过消息暴露的消息原语由内核进行访问。同样，权限也受内核的保护，未授权的用户**Task**没有任何方式向没有访问权限的`Port`发送（或接收）消息。`Port`权限也不携带任何位置信息，比如，当一个`接收`权限从一个**Task**移动到另外一个**Task**，甚至不在同一个机器上，`Port`的`发送`权限依然没有改变并继续起作用。