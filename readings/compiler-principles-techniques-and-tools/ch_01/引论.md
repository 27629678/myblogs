## 第一章 引论

### 1.1 语言处理器

由一个编译器产生的机器语言目标程序比一个解释器快很多。然而，解释器的错误诊断效果通常比编译器更好，因为它逐个语句地执行源程序。

编译器可能产生一个汇编语言程序作为其输出，因为汇编语言比较容易调试和输出。

### 1.2 一个编译器的结构

- 前端：把程序分解成多个组成要素；
- 后端：根据中间表示和符号表中的信息来构造用户期待的目标程序。

#### 1.2.1 语法分析

编译器的第一个步骤称为`词法分析`（lexical analysis），其读入组成源程序的字符流，并且将它们组织成为有意义的`词素`（lexeme）的序列。对于每个`词素`，词法分析器产生如下形式的`词法单元`（token）作为输出；

```
<token-name, attribute-value>
```

例如如下赋值语句：

```
position = initial + rate * 60;
```

其中，`词素`如下：

- position, 对应的词法单元<id, 1>
- =, 对应的词法单元<=>
- initail，对应的词法单元<id, 2>
- +，对应的词法单元<+>
- rate，对应的词法单元<id, 3>
- *，对应的词法单元<*>
- 60，对应的词法单元<60>

经过分析之后，得到如下词法单元序列：

```
<id, 1> <=> <id, 2> <+> <id, 3> <*> <60>
```

#### 1.2.2 语法分析

一个常用的表示方法是`语法树`（syntax tree），树中的每个**内部**节点表示一个运算，而该节点的子节点表示该运算的分量，即操作对象；

#### 1.2.3 语义分析

语义分析器使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。

#### 1.2.4 中间代码生成

中间表示应该具有两个重要的性质：它应该易于生成，且能够被轻松地翻译为目标机器上的语言。

比如如下三地址代码序列：

```
t1 = inttofloat(60)
t2 = id3 * t1
t3 = id2 + t2
id1 = t3
```

#### 1.2.5 代码优化

略

#### 1.2.6 代码生成

代码生成的一个至关重要的方面是合理分配寄存器以存放变量的值。

```
LDF  R2, id3
MULF R2, R2, #60.0
LDF  R1, id2
ADDF R1, R1, R2
STF  id1, R1
```

#### 1.2.9 编译器构造工具

和任何软件开发者一样，写编译器的人可以充分利用现代的软件开发环境。这些环境中包含了诸如语言编辑器，调试器，版本管理，程序扫描器和测试管理等工具。

#### 1.4.1 编译器设计和实现中的建模

对编译器的研究主要是有关如何设计正确的数学模型和选择正确算法的研究。设计和选择时，还需要考虑到对通用性及功能的要求与简单性及有效性之间的平衡。

#### 1.4.2 代码优化的科学

如果想使得编译器产生经过良好优化的代码，图、矩阵和线性规划之类的模型是必不可少的。

在编译器的设计中，最重要的技能之一是明确描述出真正要解决的问题的能力。

编译器优化必须满足下面的设计目标：

- 优化必须是正确的，也就是说，不能改变被编译程序的含义。
- 优化必须能够改善很多程序的性能。
- 优化所需要的时间必须保持在合理的范围人。
- 所需要的工程方面的工作必须是可管理的。

#### 1.5.4 程序翻译

##### 二进制翻译

1994年，当Apple Macintosh中的处理器从Motorola MC68040变为PowerPC的时候，便使用二进制翻译来支持PowerPC处理器运行遗留下来的MC68040代码。

##### 硬件合成

VHDL语言，如何从语言转换为最后的硬件集成电路的；

#### 1.5.5 软件生产率工具

##### 内存管理工具

垃圾回收机制是在效率和易编程及软件可靠性之间进行折衷处理的另一个极好的例子。

#### 1.6.5 动态作用域

动态作用域的例子：C预处理器中的宏扩展，以及面向对象编程中的方法解析；

#### 1.6.6 参数传递机制

##### 引用调用

原因是严格的值调用要求调用者把整个实参拷贝到属于相应形参的空间上。当参数很大时，这种拷贝可能代价高昂。

