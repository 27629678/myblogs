##线程安全缓存类设计

直接上代码吧，本文中使用了GCD的`dispatch_barrier_async`和`dispatch_barrier_sync`两个方法来实现，此处的`barrier`类似于[Memory Barrie][MB_Link];

```
dispatch_queue_t aQueue = 
dispatch_queue_create("queue name", DISPATCH_QUEUE_CONCURRENT);

- (NSDictionary *)getSomeData
{
  NSDictionary* retDict = nil;
  dispatch_sync(aQueue, ^{
        // do some thing for data
        // assign data to retDict
    });

  return retDict;
}

- (void)setSomeData:(NSDictionary *)dict
{
  dispatch_barrier_async(aQueue, ^{
      // populate dict into data
      // cache store new data
    });
}
```

读缓存内的数据时可以并发的去读，此时数据是线程安全的。

写入数据时，使用了`barrier`，该方法等待**aQueue**上前面的任务都完成了再执行该Block，该Block执行期间禁止其它的Block执行，该Block执行完成后再恢复队列的并发特性，这使得该缓存内的数据可以是线程安全的。

>When submitted to a a global queue or to a queue not created with the DISPATCH_QUEUE_CONCURRENT attribute, barrier blocks behave identically to blocks submitted with the dispatch_async()/dispatch_sync() API.


[MB_Link]:https://en.wikipedia.org/wiki/Memory_barrier "MB Wiki Link"
