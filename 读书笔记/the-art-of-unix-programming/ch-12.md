## Chapter 12 Optimization(优化)

*Premature optimization is the root of all evil.*

过早的优化及万恶之源。

            -- C. A. R. Hoare

关于性能优化，Unix的经验告诉我们最主要的就是如何知道何时不去优化。其次，最有效的优化往往是优化之外的事情，如：清晰干净的设计。

### 1.1 什么也别做，就站在那儿

程序员工具箱中最强大的优化技术就是不做优化；

别去优化一个工作中的系统：比如，摩尔定律的指数效应告诉我们——最聪明，最便宜，通常也是最迅速的性能提升方法，就是等上几个月，期望硬件性能更好。

> NOTE：这是有数学上的理由的；如果仅仅只是为了减少资源使用的一个常数部分而优化，那是很不值得的。更明智的做法是集中精力将时间复杂度或空间复杂度从O(n^2)降至O(n)或O(nlogn)，或者类似地，从一个更高次的指数降下来。线性性能增益往往很快就会被摩尔定律覆盖了。

### 1.2 先估量，后优化

如果真有真凭实据证明应用程序运行缓慢，这时（仅当此时）才可以考虑优化代码。但付诸实施前，要先估量；

### 1.3 非定域性之害

最有效的代码优化方法就是保持代码短小简单。

### 1.4 吞吐量和延迟

在编写应用程序时，对于昂贵的计算操作，通常面临这样的选择，是一次计算反复使用，还是按需计算（即使那意味着经常重复计算）。在多数情况下，如果面临如此的选择，正确的做法是偏向**低延时**。也就是说，不要预先计算昂贵的操作，除非存在**吞吐量**的要求，并且通过测量确切知道吞吐量确实很低。预先计算看起来似乎很有效率，因为它最小化了处理器周期的使用，然而处理周期是廉价的。除非在做计算密集的应用程序，如数据挖掘，动画渲染等；否则，更好的选择是**短暂的启动和快速的响应**。

认为迫切需要缓存的时候，明智的做法是能够从更深层次来考虑，并问问为什么缓存是必须的，这比将缓存的所有边界条件都考虑到要容易的多。
